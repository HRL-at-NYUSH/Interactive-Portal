{"ast":null,"code":"// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n(function (glob) {\n  var version = \"0.5.4\",\n      has = \"hasOwnProperty\",\n      separator = /[\\.\\/]/,\n      comaseparator = /\\s*,\\s*/,\n      wildcard = \"*\",\n      numsort = function (a, b) {\n    return a - b;\n  },\n      current_event,\n      stop,\n      events = {\n    n: {}\n  },\n      firstDefined = function () {\n    for (var i = 0, ii = this.length; i < ii; i++) {\n      if (typeof this[i] != \"undefined\") {\n        return this[i];\n      }\n    }\n  },\n      lastDefined = function () {\n    var i = this.length;\n\n    while (--i) {\n      if (typeof this[i] != \"undefined\") {\n        return this[i];\n      }\n    }\n  },\n      objtos = Object.prototype.toString,\n      Str = String,\n      isArray = Array.isArray || function (ar) {\n    return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n  },\n\n  /*\\\n   * eve\n   [ method ]\n    * Fires event with given `name`, given scope and other parameters.\n    - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n   - scope (object) context for the event handlers\n   - varargs (...) the rest of arguments will be sent to event handlers\n    = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n  \\*/\n  eve = function (name, scope) {\n    var oldstop = stop,\n        args = Array.prototype.slice.call(arguments, 2),\n        listeners = eve.listeners(name),\n        z = 0,\n        l,\n        indexed = [],\n        queue = {},\n        out = [],\n        ce = current_event;\n    out.firstDefined = firstDefined;\n    out.lastDefined = lastDefined;\n    current_event = name;\n    stop = 0;\n\n    for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n      indexed.push(listeners[i].zIndex);\n\n      if (listeners[i].zIndex < 0) {\n        queue[listeners[i].zIndex] = listeners[i];\n      }\n    }\n\n    indexed.sort(numsort);\n\n    while (indexed[z] < 0) {\n      l = queue[indexed[z++]];\n      out.push(l.apply(scope, args));\n\n      if (stop) {\n        stop = oldstop;\n        return out;\n      }\n    }\n\n    for (i = 0; i < ii; i++) {\n      l = listeners[i];\n\n      if (\"zIndex\" in l) {\n        if (l.zIndex == indexed[z]) {\n          out.push(l.apply(scope, args));\n\n          if (stop) {\n            break;\n          }\n\n          do {\n            z++;\n            l = queue[indexed[z]];\n            l && out.push(l.apply(scope, args));\n\n            if (stop) {\n              break;\n            }\n          } while (l);\n        } else {\n          queue[l.zIndex] = l;\n        }\n      } else {\n        out.push(l.apply(scope, args));\n\n        if (stop) {\n          break;\n        }\n      }\n    }\n\n    stop = oldstop;\n    current_event = ce;\n    return out;\n  }; // Undocumented. Debug only.\n\n\n  eve._events = events;\n  /*\\\n   * eve.listeners\n   [ method ]\n    * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n    - name (string) name of the event, dot (`.`) or slash (`/`) separated\n    = (array) array of event handlers\n  \\*/\n\n  eve.listeners = function (name) {\n    var names = isArray(name) ? name : name.split(separator),\n        e = events,\n        item,\n        items,\n        k,\n        i,\n        ii,\n        j,\n        jj,\n        nes,\n        es = [e],\n        out = [];\n\n    for (i = 0, ii = names.length; i < ii; i++) {\n      nes = [];\n\n      for (j = 0, jj = es.length; j < jj; j++) {\n        e = es[j].n;\n        items = [e[names[i]], e[wildcard]];\n        k = 2;\n\n        while (k--) {\n          item = items[k];\n\n          if (item) {\n            nes.push(item);\n            out = out.concat(item.f || []);\n          }\n        }\n      }\n\n      es = nes;\n    }\n\n    return out;\n  };\n  /*\\\n   * eve.separator\n   [ method ]\n    * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n   * here. Be aware that if you pass a string longer than one character it will be treated as\n   * a list of characters.\n    - separator (string) new separator. Empty string resets to default: `.` or `/`.\n  \\*/\n\n\n  eve.separator = function (sep) {\n    if (sep) {\n      sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n      sep = \"[\" + sep + \"]\";\n      separator = new RegExp(sep);\n    } else {\n      separator = /[\\.\\/]/;\n    }\n  };\n  /*\\\n   * eve.on\n   [ method ]\n   **\n   * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n   | eve.on(\"*.under.*\", f);\n   | eve(\"mouse.under.floor\"); // triggers f\n   * Use @eve to trigger the listener.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n   **\n   - name (array) if you don’t want to use separators, you can use array of strings\n   - f (function) event handler function\n   **\n   = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n   > Example:\n   | eve.on(\"mouse\", eatIt)(2);\n   | eve.on(\"mouse\", scream);\n   | eve.on(\"mouse\", catchIt)(1);\n   * This will ensure that `catchIt` function will be called before `eatIt`.\n   *\n   * If you want to put your handler before non-indexed handlers, specify a negative value.\n   * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n  \\*/\n\n\n  eve.on = function (name, f) {\n    if (typeof f != \"function\") {\n      return function () {};\n    }\n\n    var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n\n    for (var i = 0, ii = names.length; i < ii; i++) {\n      (function (name) {\n        var names = isArray(name) ? name : Str(name).split(separator),\n            e = events,\n            exist;\n\n        for (var i = 0, ii = names.length; i < ii; i++) {\n          e = e.n;\n          e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {\n            n: {}\n          });\n        }\n\n        e.f = e.f || [];\n\n        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n          exist = true;\n          break;\n        }\n\n        !exist && e.f.push(f);\n      })(names[i]);\n    }\n\n    return function (zIndex) {\n      if (+zIndex == +zIndex) {\n        f.zIndex = +zIndex;\n      }\n    };\n  };\n  /*\\\n   * eve.f\n   [ method ]\n   **\n   * Returns function that will fire given event with optional arguments.\n   * Arguments that will be passed to the result function will be also\n   * concated to the list of final arguments.\n   | el.onclick = eve.f(\"click\", 1, 2);\n   | eve.on(\"click\", function (a, b, c) {\n   |     console.log(a, b, c); // 1, 2, [event object]\n   | });\n   - event (string) event name\n   - varargs (…) and any other arguments\n   = (function) possible event handler function\n  \\*/\n\n\n  eve.f = function (event) {\n    var attrs = [].slice.call(arguments, 1);\n    return function () {\n      eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n    };\n  };\n  /*\\\n   * eve.stop\n   [ method ]\n   **\n   * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n  \\*/\n\n\n  eve.stop = function () {\n    stop = 1;\n  };\n  /*\\\n   * eve.nt\n   [ method ]\n   **\n   * Could be used inside event handler to figure out actual name of the event.\n   **\n   - subname (string) #optional subname of the event\n   **\n   = (string) name of the event, if `subname` is not specified\n   * or\n   = (boolean) `true`, if current event’s name contains `subname`\n  \\*/\n\n\n  eve.nt = function (subname) {\n    var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n\n    if (subname) {\n      return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n    }\n\n    return cur;\n  };\n  /*\\\n   * eve.nts\n   [ method ]\n   **\n   * Could be used inside event handler to figure out actual name of the event.\n   **\n   **\n   = (array) names of the event\n  \\*/\n\n\n  eve.nts = function () {\n    return isArray(current_event) ? current_event : current_event.split(separator);\n  };\n  /*\\\n   * eve.off\n   [ method ]\n   **\n   * Removes given function from the list of event listeners assigned to given name.\n   * If no arguments specified all the events will be cleared.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n  \\*/\n\n  /*\\\n   * eve.unbind\n   [ method ]\n   **\n   * See @eve.off\n  \\*/\n\n\n  eve.off = eve.unbind = function (name, f) {\n    if (!name) {\n      eve._events = events = {\n        n: {}\n      };\n      return;\n    }\n\n    var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n\n    if (names.length > 1) {\n      for (var i = 0, ii = names.length; i < ii; i++) {\n        eve.off(names[i], f);\n      }\n\n      return;\n    }\n\n    names = isArray(name) ? name : Str(name).split(separator);\n    var e,\n        key,\n        splice,\n        i,\n        ii,\n        j,\n        jj,\n        cur = [events],\n        inodes = [];\n\n    for (i = 0, ii = names.length; i < ii; i++) {\n      for (j = 0; j < cur.length; j += splice.length - 2) {\n        splice = [j, 1];\n        e = cur[j].n;\n\n        if (names[i] != wildcard) {\n          if (e[names[i]]) {\n            splice.push(e[names[i]]);\n            inodes.unshift({\n              n: e,\n              name: names[i]\n            });\n          }\n        } else {\n          for (key in e) if (e[has](key)) {\n            splice.push(e[key]);\n            inodes.unshift({\n              n: e,\n              name: key\n            });\n          }\n        }\n\n        cur.splice.apply(cur, splice);\n      }\n    }\n\n    for (i = 0, ii = cur.length; i < ii; i++) {\n      e = cur[i];\n\n      while (e.n) {\n        if (f) {\n          if (e.f) {\n            for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n              e.f.splice(j, 1);\n              break;\n            }\n\n            !e.f.length && delete e.f;\n          }\n\n          for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n            var funcs = e.n[key].f;\n\n            for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n              funcs.splice(j, 1);\n              break;\n            }\n\n            !funcs.length && delete e.n[key].f;\n          }\n        } else {\n          delete e.f;\n\n          for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n            delete e.n[key].f;\n          }\n        }\n\n        e = e.n;\n      }\n    } // prune inner nodes in path\n\n\n    prune: for (i = 0, ii = inodes.length; i < ii; i++) {\n      e = inodes[i];\n\n      for (key in e.n[e.name].f) {\n        // not empty (has listeners)\n        continue prune;\n      }\n\n      for (key in e.n[e.name].n) {\n        // not empty (has children)\n        continue prune;\n      } // is empty\n\n\n      delete e.n[e.name];\n    }\n  };\n  /*\\\n   * eve.once\n   [ method ]\n   **\n   * Binds given event handler with a given name to only run once then unbind itself.\n   | eve.once(\"login\", f);\n   | eve(\"login\"); // triggers f\n   | eve(\"login\"); // no listeners\n   * Use @eve to trigger the listener.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n   **\n   = (function) same return function as @eve.on\n  \\*/\n\n\n  eve.once = function (name, f) {\n    var f2 = function () {\n      eve.off(name, f2);\n      return f.apply(this, arguments);\n    };\n\n    return eve.on(name, f2);\n  };\n  /*\\\n   * eve.version\n   [ property (string) ]\n   **\n   * Current version of the library.\n  \\*/\n\n\n  eve.version = version;\n\n  eve.toString = function () {\n    return \"You are running Eve \" + version;\n  };\n\n  glob.eve = eve;\n  typeof module != \"undefined\" && module.exports ? module.exports = eve : typeof define === \"function\" && define.amd ? define(\"eve\", [], function () {\n    return eve;\n  }) : glob.eve = eve;\n})(typeof window != \"undefined\" ? window : this);","map":{"version":3,"sources":["/Users/almazhan/Desktop/Visualization-Project-main/front-end/node_modules/eve/eve.js"],"names":["glob","version","has","separator","comaseparator","wildcard","numsort","a","b","current_event","stop","events","n","firstDefined","i","ii","length","lastDefined","objtos","Object","prototype","toString","Str","String","isArray","Array","ar","call","eve","name","scope","oldstop","args","slice","arguments","listeners","z","l","indexed","queue","out","ce","push","zIndex","sort","apply","_events","names","split","e","item","items","k","j","jj","nes","es","concat","f","sep","replace","RegExp","on","exist","hasOwnProperty","event","attrs","nt","subname","cur","join","test","nts","off","unbind","key","splice","inodes","unshift","funcs","prune","once","f2","module","exports","define","amd","window"],"mappings":"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","sourcesContent":["// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n\n(function (glob) {\n    var version = \"0.5.4\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        comaseparator = /\\s*,\\s*/,\n        wildcard = \"*\",\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        objtos = Object.prototype.toString,\n        Str = String,\n        isArray = Array.isArray || function (ar) {\n            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n        },\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n        eve = function (name, scope) {\n            var oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event;\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n    // Undocumented. Debug only.\n    eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/\n    eve.listeners = function (name) {\n        var names = isArray(name) ? name : name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    /*\\\n     * eve.separator\n     [ method ]\n\n     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n     * here. Be aware that if you pass a string longer than one character it will be treated as\n     * a list of characters.\n\n     - separator (string) new separator. Empty string resets to default: `.` or `/`.\n    \\*/\n    eve.separator = function (sep) {\n        if (sep) {\n            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n            sep = \"[\" + sep + \"]\";\n            separator = new RegExp(sep);\n        } else {\n            separator = /[\\.\\/]/;\n        }\n    };\n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     - name (array) if you don’t want to use separators, you can use array of strings\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n    \\*/\n    eve.on = function (name, f) {\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = isArray(name) ? name : Str(name).split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     - event (string) event name\n     - varargs (…) and any other arguments\n     = (function) possible event handler function\n    \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n    \\*/\n    eve.nt = function (subname) {\n        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n        }\n        return cur;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/\n    eve.nts = function () {\n        return isArray(current_event) ? current_event : current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = isArray(name) ? name : Str(name).split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events],\n            inodes = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                        inodes.unshift({\n                            n: e,\n                            name: names[i]\n                        });\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                        inodes.unshift({\n                            n: e,\n                            name: key\n                        });\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n        // prune inner nodes in path\n        prune: for (i = 0, ii = inodes.length; i < ii; i++) {\n            e = inodes[i];\n            for (key in e.n[e.name].f) {\n                // not empty (has listeners)\n                continue prune;\n            }\n            for (key in e.n[e.name].n) {\n                // not empty (has children)\n                continue prune;\n            }\n            // is empty\n            delete e.n[e.name];\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.off(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    glob.eve = eve;\n    typeof module != \"undefined\" && module.exports ? module.exports = eve : typeof define === \"function\" && define.amd ? define(\"eve\", [], function () { return eve; }) : glob.eve = eve;\n})(typeof window != \"undefined\" ? window : this);\n"]},"metadata":{},"sourceType":"script"}